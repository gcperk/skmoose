---
title: "Moose_survey"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Moose_survey}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval=FALSE}
library(skmoose)
library(sf)
library(dplyr)
library(terra)
library(foreach)

```

# Introduction

This package assists in determining moose quality and extent of usable habitat for each block given study area. This vignette provides a detailed version of the functions and how to step through each component in the process. 

## Preparation 

Firstly we will read in the survey block layout. Ideally this geospatial file will be in .gpkg format, however a helper function is provide to convert a .shp file to .gpkg. An example data set is provided within the package. The workflow will use this example dataset, however notes are provided to assist in using your own data set.  


```{r}
# read in the test data 

data_location <- fs::path_package("extdata", package = "skmoose")
data_file <- skmoose::skmoose_example()
bks_name <- file.path(data_location, data_file)

# Alternatively you can read in an entire dataset by pointing to the file location as shown below: 

#bks_name <- file.path("C:\\Users\\genev\\OneDrive\\Documents\\02.Contracts\\2023_oddjobs\\2023_moose_block_surveyR\\02.Data", "Tweedsmuir-SRBblocks.gpkg")

```

Read in the file and generate an individual block id number 

```{r}
# read in and format the data 
aoi <- sf::st_read(file.path(bks_name))
aoi <- aoi %>%
  dplyr::mutate(bkname = seq(1,length(aoi$Name), 1)) %>%
  dplyr::select(bkname)%>%
  st_zm()

# generate a list with all unique block numbers to be used to iterate through the spatial extraction

blockno <- as.list(unique(aoi$bkname))

```

Create an ouput folder where you want the raw data geospatial data to be saved. Note a folder will be generated for each block number (labelled numerically). 

```{r}
# create an output folder: 
out_dir <- "C:\\Users\\genev\\OneDrive\\Documents\\02.Contracts\\2023_oddjobs\\2023_moose_block_surveyR\\02.Data\\data"


# check if the folder already exists and if it doesnt create a folder
if (!dir.exists(out_dir )){
  dir.create(out_dir )
}else{
  print("dir exists")
}

# write out a copy of the full aoi 
sf::st_write(aoi, file.path(out_dir, "aoi.gpkg"), append = FALSE)

```

We can now begin to extract the base data for each block. This uses the bcdata and bcmaps package to pull data directly from the bcdata catalogue. The process is set up to iterate over each block. While this is not very fast, it provides a more stable method to reduce the incidence of timing out during large data downloads, specifically with the VRI dataset. 

**WARNING**: this is the most time consuming part of the process and will take some time to run if extracting many blocks. Best to run overnight. 


```{r}
# set up parrallel processing parameters
registerDoSEQ()

# loop through each block and extract the basedata. These will be filtered and a copy saved under the respective file folder. 

basedata <- foreach(x = blockno[1:5]) %dopar% {
  
  # test line - if you want to run a single block 
  #x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
      if (!dir.exists(temp_out_dir)){
        dir.create(temp_out_dir )
      }else{
        print("dir exists")
      }

      get_basedata(in_aoi = tmp_aoi, out_path = temp_out_dir)
  
  print(x)
  
}


#get_basedata(in_aoi = aoi_simple, out_path = out_dir)
#get_basedata(in_aoi = aoi, out_path = out_dir)


```

## Extract uninhabitable area

Once all the base data is extracted we can filter uninhabitable areas for moose. 
This includes : 

- Rock and Ice 
- Waterbodies >1 km2
- Elevations >1500 m 
- Slopes >55 degrees

If there are sections within the study area that meet these criteria they will be saved as a new .gpkg within the folder of the particular block. If no additional files are written out, then the criteria are not met. 

```{r}
uninhab <- foreach(x = blockno[1:5]) %dopar% {
  
  #x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
      
  # 1. extract rock and ice areas
    
  rockice <- st_read(file.path(temp_out_dir, "vri.gpkg")) %>%
      dplyr::filter(BCLCS_LEVEL_3 == "A") %>%
      dplyr::select(id) %>%
      st_union()%>%
      st_cast("MULTIPOLYGON")
    
     if(length(st_is_empty(rockice)< 1)){
      sf::st_write(rockice, file.path(temp_out_dir, "rockice.gpkg"), append = FALSE)
    }

  # 2. filter lakes with >1 km2

  largelakes <- st_read(file.path(temp_out_dir, "lakes.gpkg")) %>%
      dplyr::filter(AREA_HA > 100) %>%
      st_union()

     if(length(st_is_empty(largelakes)< 1)){
    st_write(largelakes, file.path(temp_out_dir, "largelakes.gpkg"), append = FALSE)
    }

  # 3. filter elevations above threshold value

  eval_threshold = 1500

  trim <- terra::rast(file.path(temp_out_dir, "dem.tif"))
  high_elev_sf <- high_elev(trim, eval_threshold )
  
  if(length(st_is_empty(high_elev_sf )< 1)){
    st_write(high_elev_sf , file.path(temp_out_dir, "high_elevation.gpkg"), append = FALSE)
    }

  # 4. filter high slope 
   slope_threshold = 55
  
   steep_sf <- steep_slope(trim, slope_threshold)
   
   if(length(st_is_empty(steep_sf )< 1)){
   st_write(steep_sf, file.path(temp_out_dir, "steep.gpkg"), append = FALSE)
   }
 
}
```


# Combine uninhabitable area. 

For each block we then combine the uninhabitable area into a single polygon and clip to the block boundary. The output file will be called "uninhabitable.gpkg"

```{r}
# merge uninhabitable area 

uninhab <- foreach(x = blockno[1:4]) %dopar% {
  
  #x = blockno[197]
  print(x)
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
  merge_nonhabit(tmp_aoi, temp_out_dir)
    
     }
   
```

## Extract Moose Habitat

We now compiled all the moose habitat areas. This involves reading in the base data and filtering for 

- Deciduous tree species, queried in VRI: [SPECIES_CD LIKE 'A%' OR SPECIES_CD = 'EP' OR SPECIES_CD = 'SB' OR SPECIES__1 LIKE 'A%' OR SPECIES__1 = 'EP' OR SPECIES__1 = 'SB' OR SPECIES__3 LIKE 'A%' OR SPECIES__3 = 'EP' OR SPECIES__3 ='SB' OR SPECIES__5 LIKE 'A%' OR SPECIES__5 LIKE 'E%']

- Early seral/shrub dynamic habitats: Fires that are >5 and <40 years old 
- Cutblocks that are  >5 and < 40 years old 
- Buffered 3-8 order streams from FWA stream dataset by 150m (dissolved) 
- 9th order streams buffered by 500 meters. 
o	Wetlands from FWA â‰¤ 1 km2
o	Skeena Wildlife Ecological Resource Model- Winter forage output 



```{r}

habitable <- foreach(x = blockno[1:4]) %dopar% {
  
   # x = blockno[10]
    print(x)
  
    tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
    temp_out_dir <- file.path(out_dir, x)

    # get deciduous leading species
    vri <- st_read(file.path(temp_out_dir, "vri.gpkg"),quiet = TRUE)
    species_codes = c("AT", "AC","EP","SB")
    decid <- vri_browse(vri, species_codes)

    if(length(st_is_empty(decid)< 1)){
        print("contains deciduous")
    st_write(decid , file.path(temp_out_dir, "vri_decid.gpkg") , append = FALSE,quiet = TRUE)
    }
    
  
   # get recent harvest 
    if("cutblocks.gpkg"  %in% list.files(temp_out_dir)){
  
      cutblocks <- st_read(file.path(temp_out_dir, "cutblocks.gpkg"),quiet = TRUE)
      cutblocks_yrs <- cutblocks_recent(cutblocks, cutblock_min_yr = 5, cutblock_max_yr = 40)
      
    if(length(st_is_empty(decid)) > 0 ){
       print("contains cutblocks")
    st_write(cutblocks_yrs, file.path(temp_out_dir, "cutblocks_filtered.gpkg"), quiet = TRUE, append = FALSE)
    }
  }
  
  # get recent fire years 

   if("fire.gpkg" %in% list.files(temp_out_dir)){
    
     
  fires <- st_read(file.path(temp_out_dir, "fire.gpkg"),quiet = TRUE)
  fires_filtered <- fires_recent(fires, fire_min_yr = 5, fire_max_yr = 40 )
  
   if(length(st_is_empty(fires)) > 0 ){
     
      print("contains fire")
     
  st_write(fires, file.path(temp_out_dir, "fires_filtered.gpkg"), append = FALSE,quiet = TRUE)
      }
   }
    
    
  # get stream order and buffer by stream order, stream order 3 - 8 is 150m buffer, stream order 9 bufferd by 500m 
  
   if("streams.gpkg"  %in% list.files(temp_out_dir)){

    streams <- st_read(file.path(temp_out_dir, "streams.gpkg"), quiet = TRUE) 
    stream38 <- buffer_streams(streams)
    stream9 <- buffer_streams(streams, 9, 500)
  
    
    if(length(st_is_empty(stream38 )) > 0 ){
        print("contains streams")
   st_write(stream38 , file.path(temp_out_dir, "streams3_8.gpkg"),quiet = TRUE, append = FALSE)
}

    if(length(st_is_empty(stream9 )) > 0 ){
   st_write(stream9 , file.path(temp_out_dir, "streams9.gpkg"), quiet = TRUE, append = FALSE)
}
    
    
   }
 
    # select small lakes and all wetlands (previously filtered to < 100 Ha Area. 
    
   if("lakes.gpkg" %in% list.files(temp_out_dir)){

  smalllakes <- st_read(file.path(temp_out_dir, "lakes.gpkg"),quiet = TRUE)%>%
     dplyr::filter(AREA_HA < 100) %>%
     st_union()
    

   if(length(st_is_empty(smalllakes)) > 0 ){
     print("contains lakes")
  st_write(smalllakes, file.path(temp_out_dir, "smalllakes.gpkg"), quiet = TRUE, append = FALSE)
      }
   }
    
  #Skeena Wildlife Ecological Resource Model- Winter forage output 
  # STILL TO ADD
  
}
  

```


#### Merge habitable layers into single file per block

For each block we then combine all the outputs into a single moose habitat layer called "habitat.gpkg".

```{r}
# merge uninhabitable area 

habitable <- foreach(x = blockno[c(1:4)]) %dopar% {
  
 # x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
  merge_habit(tmp_aoi, temp_out_dir)
    
  # remove an uninhabitable areas from within habitable 
  
  if(file.exists(file.path(temp_out_dir,"uninhabitable.gpkg"))){
 
     uninh <- st_read(file.path(temp_out_dir, "uninhabitable.gpkg"),quiet = TRUE)
     hab <- st_read(file.path(temp_out_dir, "habitable.gpkg"),quiet = TRUE)
  
    habit <- st_intersection(uninh,  hab)
    final_hab <- st_difference(hab, uninh)
    st_write(final_hab, file.path(temp_out_dir, "habitable.gpkg"), quiet = TRUE, append = FALSE)
  
    }
  
     }
   
```


## Calculate areas for habitat and non-habitable

For each block we will read in the habitable and inhabitable areas and calculate the areas and proportions for each block. A table is


```{r}

out_table <- calculate_areas(blockno[1:4], aoi, out_dir)


write.csv(out_table, file.path(out_dir, "survey_areas.csv"))


```


# Moose Habitat Strata Classification 
  
#This will likely be based on Proportion of Moose Habitat/Block Area (Column G). Breaks #in proportions to be determined.
  
  
```{r}
  library(ggplot2)
  
  ggplot(area_final, aes(prop_habit_block_m2))+ 
  geom_bar()
  
```

  
 
