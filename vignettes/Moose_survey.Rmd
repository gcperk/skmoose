---
title: "Moose_survey"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Moose_survey}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval=FALSE}
library(skmoose)
library(sf)
library(dplyr)
library(terra)

```

# Introduction

This package assists in determining moose quality and extent of usable habitat for each block given study area. 

Read in the survey blocks file. We will use a test subset provided with the package as an example. Note this file is preffered to be in .gpkg format, however see below for an example of converting a .shp to .gpkg file. 

```{r}

# read in the test data 

data_location <- fs::path_package("extdata", package = "skmoose")
data_file <- skmoose::skmoose_example()
#bks_name <- file.path(data_location, data_file)


# or the full data set: 

bks_name <- file.path("C:\\Users\\genev\\OneDrive\\Documents\\02.Contracts\\2023_oddjobs\\2023_moose_block_surveyR\\02.Data", "Tweedsmuir-SRBblocks.gpkg")

# read in and format the data 
aoi <- sf::st_read(file.path(bks_name))
aoi <- aoi %>%
  dplyr::mutate(bkname = seq(1,length(aoi$Name), 1)) %>%
  dplyr::select(bkname)%>%
  st_zm()


blockno <- as.list(unique(aoi$bkname))
  
# simplify the blocks into a single polygon to extract for the entire area. 
#aoi_simple <- st_union(aoi)

```

Create an ouput folder where you want the raw data geospatial data to be saved. 

```{r}

out_dir <- "C:\\Users\\genev\\OneDrive\\Documents\\02.Contracts\\2023_oddjobs\\2023_moose_block_surveyR\\02.Data\\data"


if (!dir.exists(out_dir )){
  dir.create(out_dir )
}else{
  print("dir exists")
}

sf::st_write(aoi, file.path(out_dir, "aoi.gpkg"), append = FALSE)

```

```{r}
# extract all base data

library(foreach)
registerDoSEQ()

basedata <- foreach(x = blockno[1:10]) %dopar% {
  
  #x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
      if (!dir.exists(temp_out_dir)){
        dir.create(temp_out_dir )
      }else{
        print("dir exists")
      }

      get_basedata(in_aoi = tmp_aoi, out_path = temp_out_dir)
  
  print(x)
  
}


#get_basedata(in_aoi = aoi_simple, out_path = out_dir)
#get_basedata(in_aoi = aoi, out_path = out_dir)


```

Once all the base data is extracted we can filter uninhabitable areas for moose. 
This includes : 

- Rock and Ice 
- Waterbodies >1 km2
- Elevations >1500 m 
- Slopes >55 degrees


```{r}
uninhab <- foreach(x = blockno[1:8]) %dopar% {
  
  x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
      
  # 1. extract rock and ice areas
    
  rockice <- st_read(file.path(temp_out_dir, "vri.gpkg")) %>%
      dplyr::filter(BCLCS_LEVEL_3 == "A") %>%
      dplyr::select(id) %>%
      st_union()%>%
      st_cast("MULTIPOLYGON")
    
     if(length(st_is_empty(rockice)< 1)){
      sf::st_write(rockice, file.path(temp_out_dir, "rockice.gpkg"), append = FALSE)
    }

  # 2. filter lakes with >1 km2

  largelakes <- st_read(file.path(temp_out_dir, "lakes.gpkg")) %>%
      dplyr::filter(AREA_HA > 100) %>%
      st_union()

     if(length(st_is_empty(largelakes)< 1)){
    st_write(largelakes, file.path(temp_out_dir, "largelakes.gpkg"), append = FALSE)
    }

  # 3. filter elevations above threshold value

  eval_threshold = 1500

  trim <- terra::rast(file.path(temp_out_dir, "dem.tif"))
  high_elev_sf <- high_elev(trim, eval_threshold )
  
  if(length(st_is_empty(high_elev_sf )< 1)){
    st_write(high_elev_sf , file.path(temp_out_dir, "high_elevation.gpkg"), append = FALSE)
    }

  # 4. filter high slope 
   slope_threshold = 55
  
   steep_sf <- steep_slope(trim, slope_threshold)
   
   if(length(st_is_empty(steep_sf )< 1)){
   st_write(steep_sf, file.path(temp_out_dir, "steep.gpkg"), append = FALSE)
   }
 
}
```


# combine the uninhabitable area for each block

```{r}
# merge uninhabitable area 

uninhab <- foreach(x = blockno[1:8]) %dopar% {
  
  x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
  merge_nonhabit(tmp_aoi, temp_out_dir)
    
     }
   
```



We now compiled all the moose habitat areas 
This includes : 
- Deciduous tree species, queried in VRI: [SPECIES_CD LIKE 'A%' OR SPECIES_CD = 'EP' OR SPECIES_CD = 'SB' OR SPECIES__1 LIKE 'A%' OR SPECIES__1 = 'EP' OR SPECIES__1 = 'SB' OR SPECIES__3 LIKE 'A%' OR SPECIES__3 = 'EP' OR SPECIES__3 ='SB' OR SPECIES__5 LIKE 'A%' OR SPECIES__5 LIKE 'E%']

- Early seral/shrub dynamic habitats: Fires that are >5 and <40 years old 
** this one I might have to think about a bit more as basically the entire study area has burnt in 2014, 2018, 2021 or 2023. In 2018 we created a 4th stratum called Burnt so may look at potentially completed this again.

o	Cutblocks that are >5 and < 40 years old 
o	Buffered 3-8 order streams from FWA stream dataset by 150m (dissolved) 
o	9th order streams buffered by 500 meters. 
o	Wetlands from FWA â‰¤ 1 km2
o	Skeena Wildlife Ecological Resource Model- Winter forage output 



```{r}

habitable <- foreach(x = blockno[1:8]) %do% {
  
    x = blockno[10]
    print(x)
  
    tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
    temp_out_dir <- file.path(out_dir, x)

    
    # get deciduous leading species
    vri <- st_read(file.path(temp_out_dir, "vri.gpkg"))
    species_codes = c("AT", "AC","EP","SB")
    decid <- vri_browse(vri, species_codes)

    if(length(st_is_empty(decid)< 1)){
    st_write(decid , file.path(temp_out_dir, "vri_decid.gpkg") , append = FALSE)
    }
    
  
   # get recent harvest 
    
    if("cutblocks.gpkg"  %in% list.files(temp_out_dir)){
      print("contains cutblocks")
  
      cutblocks <- st_read(file.path(temp_out_dir, "cutblocks.gpkg"))
      cutblocks_yrs <- cutblocks_recent(cutblocks, cutblock_min_yr = 5, cutblock_max_yr = 40)
      
    if(length(st_is_empty(decid)) > 0 ){
    st_write(cutblocks_yrs, file.path(temp_out_dir, "cutblocks_filtered.gpkg"), append = FALSE)
    }
      }


  
  # get recent fire years 

   if("fire.gpkg" %in% list.files(temp_out_dir)){
      
      print("contains fire")
     
  fires <- st_read(file.path(temp_out_dir, "fire.gpkg"))
  fires_filtered <- fires_recent(fires, fire_min_yr = 5, fire_max_yr = 40 )
  
   if(length(st_is_empty(fires)) > 0 ){
  st_write(fires, file.path(temp_out_dir, "fires_filtered.gpkg"), append = FALSE)
      }
   }
    
    
  # get stream order and buffer by stream order, stream order 3 - 8 is 150m buffer, stream order 9 bufferd by 500m 
  
# Buffered 3-8 order streams from FWA stream dataset by 150m (dissolved) 
#- 9th order streams buffered by 500 meters. 
  
   if("streams.gpkg"  %in% list.files(temp_out_dir)){
      
      print("contains streams")

    streams <- st_read(file.path(temp_out_dir, "streams.gpkg")) 
    stream38 <- buffer_streams(streams)
    stream9 <- buffer_streams(streams, 9, 500)
  
    
    if(length(st_is_empty(stream38 )) > 0 ){
   st_write(stream38 , file.path(temp_out_dir, "streams3_8.gpkg"), append = FALSE)
}

    if(length(st_is_empty(stream9 )) > 0 ){
   st_write(stream9 , file.path(temp_out_dir, "streams9.gpkg"), append = FALSE)
}
    
    
   }
 
     
    # wetlands already filtered to < 100 Ha Area
    
    
   if("lakes.gpkg" %in% list.files(temp_out_dir)){
      
      print("contains lakes")
     
  smalllakes <- st_read(file.path(temp_out_dir, "lakes.gpkg"))%>%
     dplyr::filter(AREA_HA < 100) %>%
     st_union()
    

   if(length(st_is_empty(smalllakes)) > 0 ){
  st_write(smalllakes, file.path(temp_out_dir, "smalllakes.gpkg"), append = FALSE)
      }
   }
    
    
    
    
  #Skeena Wildlife Ecological Resource Model- Winter forage output 
  
  
}
  

```



# combine the habitable area for each block

```{r}
# merge uninhabitable area 

habitable <- foreach(x = blockno[c(1:3)]) %dopar% {
  
 # x = blockno[197]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
  merge_habit(tmp_aoi, temp_out_dir)
    
  # remove an uninhabitable areas from within habitable 
  
  if(file.exists(file.path(temp_out_dir,"uninhabitable.gpkg"))){
 
     uninh <- st_read(file.path(temp_out_dir, "uninhabitable.gpkg"))
     hab <- st_read(file.path(temp_out_dir, "habitable.gpkg"))
  
      habit <- st_intersection(uninh,  hab)
    final_hab <- st_difference(hab, uninh)
    st_write(final_hab, file.path(temp_out_dir, "habitable.gpkg"), append = FALSE)
  
    }
  
     }
   
```
Calculate the areas for habitat and non-habitable in each block and output a table 


```{r}

area_tab <- foreach(x = blockno[1:3], .combine=rbind) %dopar% {
  
  #x = blockno[197]
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
  block_area <- st_area(tmp_aoi)

  if(file.exists(file.path(temp_out_dir,"uninhabitable.gpkg"))){
 
     uninh <- st_read(file.path(temp_out_dir, "uninhabitable.gpkg"))
     
     uninh_area <- st_area(uninh)
     
  } else {
    
     uninh_area <- 0
     
  }
     
  
  if(file.exists(file.path(temp_out_dir,"habitable.gpkg"))){
 
     hab <- st_read(file.path(temp_out_dir, "habitable.gpkg"))
     
     hab_area <- st_area(hab)
     
  } else {
    
     hab_area <- 0
     
  }
  
  tline <- c(x, block_area, uninh_area, hab_area)
  tline
}

  area_tab <- as.data.frame(area_tab, row.names = FALSE)
  names(area_tab) <- c("bk", "total_area_m2", "uninh_area_m2", "hab_area_m2")

  area_tab
  

```

