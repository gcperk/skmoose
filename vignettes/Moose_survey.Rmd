---
title: "Moose_survey"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Moose_survey}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval=FALSE}
library(skmoose)
library(sf)
library(dplyr)
library(terra)

```

# Introduction

This package assists in determining moose quality and extent of usable habitat for each block given study area. 

Read in the survey blocks file. We will use a test subset provided with the package as an example. Note this file is preffered to be in .gpkg format, however see below for an example of converting a .shp to .gpkg file. 

```{r}

# read in the test data 

data_location <- fs::path_package("extdata", package = "skmoose")
data_file <- skmoose::skmoose_example()
#bks_name <- file.path(data_location, data_file)


# or the full data set: 

bks_name <- file.path("C:\\Users\\genev\\OneDrive\\Documents\\02.Contracts\\2023_oddjobs\\2023_moose_block_surveyR\\02.Data", "Tweedsmuir-SRBblocks.gpkg")

# read in and format the data 
aoi <- sf::st_read(file.path(bks_name))
aoi <- aoi %>%
  dplyr::mutate(bkname = seq(1,length(aoi$Name), 1)) %>%
  dplyr::select(bkname)%>%
  st_zm()


blockno <- as.list(unique(aoi$bkname))
  
# simplify the blocks into a single polygon to extract for the entire area. 
#aoi_simple <- st_union(aoi)

```

Create an ouput folder where you want the raw data geospatial data to be saved. 

```{r}

out_dir <- "C:\\Users\\genev\\OneDrive\\Documents\\02.Contracts\\2023_oddjobs\\2023_moose_block_surveyR\\02.Data\\data"


if (!dir.exists(out_dir )){
  dir.create(out_dir )
}else{
  print("dir exists")
}

sf::st_write(aoi, file.path(out_dir, "aoi.gpkg"), append = FALSE)

```

```{r}
# extract all base data

library(foreach)
basedata <- foreach(x = blockno[11:50]) %do% {
  
  #x = blockno[127]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
  
      if (!dir.exists(temp_out_dir)){
        dir.create(temp_out_dir )
      }else{
        print("dir exists")
      }

      get_basedata(in_aoi = tmp_aoi, out_path = temp_out_dir)
  
  #print(x)
  
}


#get_basedata(in_aoi = aoi_simple, out_path = out_dir)
#get_basedata(in_aoi = aoi, out_path = out_dir)


```

Once all the base data is extracted we can filter uninhabitable areas for moose. 
This includes : 

- Rock and Ice 
- Waterbodies >1 km2
- Elevations >1500 m 
- Slopes >55 degrees


```{r}


uninhab <- foreach(x = blockno[11:50]) %do% {
  
  #x = blockno[22]
  
  tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
  temp_out_dir <- file.path(out_dir, x)
      
  # 1. extract rock and ice areas
    
  rockice <- st_read(file.path(temp_out_dir, "vri.gpkg")) %>%
      dplyr::filter(BCLCS_LEVEL_3 == "A") %>%
      dplyr::select(id) %>%
      st_union()%>%
      st_cast("MULTIPOLYGON")
    
     if(length(nrow(rockice)) > 0 ){
      sf::st_write(rockice, file.path(temp_out_dir, "rockice.gpkg"), append = FALSE)
    }

  # 2. filter lakes with >1 km2

  largelakes <- st_read(file.path(temp_out_dir, "lakes.gpkg")) %>%
      dplyr::filter(AREA_HA > 100) %>%
      st_union()

    if(length(nrow(largelakes)) > 0 ){
    st_write(largelakes , file.path(temp_out_dir, "largelakes.gpkg"), append = FALSE)
    }

  # 3. filter elevations above threshold value

  eval_threshold = 1500

  trim <- terra::rast(file.path(temp_out_dir, "dem.tif"))
  high_elev_sf <- high_elev(trim, eval_threshold )
  
    if(length(nrow(high_elev_sf)) > 0 ){
    st_write(high_elev_sf , file.path(temp_out_dir, "high_elevation.gpkg"), append = FALSE)
    }

  # 4. filter high slope 
   slope_threshold = 55
  
   steep_sf <- steep_slope(trim, slope_threshold)
   
   if(length(nrow(steep_sf)) > 0 ){
   st_write(steep_sf, file.path(temp_out_dir, "steep.gpkg"), append = FALSE)
   }
   
     
  # 
  # # combine uninhabited areas for moose
  # 
  #  merge_uninhabitable
  #  
  #  
  #  ####  check if exist and then merge if it does  
  #  
  #   unhab <- st_union(rockice, high_elev_sf, steep_sf, largelakes)
  #   unhab <- st_union(largelakes, rockice)
  #   unhab <- st_union(largelakes, largelakes, largelakes)
  #   unhab <- unhab %>% 
  #     st_union()
  #   
  #   # crop to the study area 
  #  unhab_all <- st_crop(unhab, tmp_aoi)
  #  
  #  st_write(unhab, file.path(temp_out_dir, "uninhabitable.gpkg"), append = FALSE)
  
   
 
}


 
 # comine uninhabited areas for moose

unhab <- st_intersection(rockice, high_elev_sf, steep_sf, largelakes)

unhab <- unhab %>% st_union()


```



We now compiled all the moose habitat areas 
This includes : 
- Deciduous tree species, queried in VRI: [SPECIES_CD LIKE 'A%' OR SPECIES_CD = 'EP' OR SPECIES_CD = 'SB' OR SPECIES__1 LIKE 'A%' OR SPECIES__1 = 'EP' OR SPECIES__1 = 'SB' OR SPECIES__3 LIKE 'A%' OR SPECIES__3 = 'EP' OR SPECIES__3 ='SB' OR SPECIES__5 LIKE 'A%' OR SPECIES__5 LIKE 'E%']

- Early seral/shrub dynamic habitats: Fires that are >5 and <40 years old 
** this one I might have to think about a bit more as basically the entire study area has burnt in 2014, 2018, 2021 or 2023. In 2018 we created a 4th stratum called Burnt so may look at potentially completed this again.

o	Cutblocks that are >5 and < 40 years old 
o	Buffered 3-8 order streams from FWA stream dataset by 150m (dissolved) 
o	9th order streams buffered by 500 meters. 
o	Wetlands from FWA â‰¤ 1 km2
o	Skeena Wildlife Ecological Resource Model- Winter forage output 



```{r}

uninhab <- foreach(x = blockno[1:5]) %do% {
  
    x = blockno[1]
    print(x)
  
    tmp_aoi <- aoi %>% dplyr::filter(bkname == x)
    temp_out_dir <- file.path(out_dir, x)

    
    # get deciduous leading species
    vri <- st_read(file.path(out_dir, "vri.gpkg"))
    species_codes = c("AT", "AC","EP","SB")
    decid <- vri_browse(vri, species_codes)

    
    if(length(nrow(decid)) > 0 ){
    st_write(decid , file.path(temp_out_dir, "vri_decid.gpkg") , append = FALSE)
    }
    
  
   # get recent harvest 
    
    if("cutblocks.gpkg"  %in% list.files(temp_out_dir)){
      
      print("contains cutblocks")
  
      cutblocks <- st_read(file.path(temp_out_dir, "cutblocks.gpkg"))
      cutblocks_yrs <- cutblocks_recent(cutblocks, cutblock_min_yr = 5, cutblock_max_yr = 40)
    if(length(nrow(decid)) > 0 ){
    st_write(cutblocks_yrs, file.path(temp_out_dir, "cutblocks_filtered.gpkg"), append = FALSE)
    }
      }


  
  # get recent fire years 

   if("fire.gpkg"  %in% list.files(temp_out_dir)){
      
      print("contains fire")
     
  fires <- st_read(file.path(out_dir, "fire.gpkg"))
  fires_filtered <- fires_recent(fires, fire_min_yr = 5, fire_max_yr = 40 )
  
   if(length(nrow(fires)) > 0 ){
  st_write(fires, file.path(temp_out_dir, "fires_filtered.gpkg"), append = FALSE)
      }
   }
    
    
  # get stream order and buffer by stream order, stream order 3 - 8 is 150m buffer, stream order 9 bufferd by 500m 
  
# Buffered 3-8 order streams from FWA stream dataset by 150m (dissolved) 
#- 9th order streams buffered by 500 meters. 
  
   if("stream.gpkg"  %in% list.files(temp_out_dir)){
      
      print("contains streams")

    streams <- st_read(file.path(temp_out_dir, "streams.gpkg")) 
    stream38 <- buffer_streams(streams)
    stream9 <- buffer_streams(streams, 9, 500)
  
    
    if(length(nrow(stream38 )) > 0 ){
   st_write(stream38 , file.path(temp_out_path, "streams3_8.gpkg"), append = FALSE)
}

    if(length(nrow(stream9 )) > 0 ){
   st_write(stream9 , file.path(temp_out_path, "streams9.gpkg"), append = FALSE)
}
    
    
   }
 
     
  # wetlands 
    
    
   if("wetlands.gpkg"  %in% list.files(temp_out_dir)){
      
      print("contains wetlands")
     
   wetlands <- st_read(file.path(temp_out_dir, "wetlands.gpkg")) 
      dplyr::filter(AREA_HA <= 100) %>%
      sf::st_union()

       if(length(nrow(wetlands)) > 0 ){
   st_write(wetlands, file.path(temp_out_path, "wetland_filter.gpkg"), append = FALSE)
}

   }
  
  
  #Skeena Wildlife Ecological Resource Model- Winter forage output 
  
  
  
}
  

```

